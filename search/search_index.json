{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"hsclient TODO Jeff","title":"hsclient"},{"location":"#hsclient","text":"TODO Jeff","title":"hsclient"},{"location":"aggregation/","text":"Represents an Aggregation in HydroShare main_file_path : str property readonly The path to the main file in the aggregation metadata : BaseMetadata property readonly A metadata object for reading and updating metadata values metadata_file property readonly The path to the metadata file metadata_path : str property readonly The path to the metadata file aggregation ( self , ** kwargs ) Returns a single Aggregation in the resource that matches the filtering parameters. Uses the same filtering rules described in the aggregations method. :params **kwargs: Search by properties on the metadata object :return: An Aggregation object matching the filter parameters or None if no matching Aggregation was found. Source code in hsclient/hydroshare.py def aggregation ( self , ** kwargs ) -> BaseMetadata : \"\"\" Returns a single Aggregation in the resource that matches the filtering parameters. Uses the same filtering rules described in the aggregations method. :params **kwargs: Search by properties on the metadata object :return: An Aggregation object matching the filter parameters or None if no matching Aggregation was found. \"\"\" aggregations = self . aggregations ( ** kwargs ) if aggregations : return aggregations [ 0 ] return None aggregations ( self , ** kwargs ) List the aggregations in the resource. Filter by properties on the metadata object using kwargs. If you need to filter on nested properties, use __ (double underscore) to separate the properties. For example, to filter by the BandInformation name, call this method like aggregations(band_information__name=\"the name to search\"). :params **kwargs: Search by properties on the metadata object :return: a List of Aggregation objects matching the filter parameters Source code in hsclient/hydroshare.py def aggregations ( self , ** kwargs ) -> List [ BaseMetadata ]: \"\"\" List the aggregations in the resource. Filter by properties on the metadata object using kwargs. If you need to filter on nested properties, use __ (double underscore) to separate the properties. For example, to filter by the BandInformation name, call this method like aggregations(band_information__name=\"the name to search\"). :params **kwargs: Search by properties on the metadata object :return: a List of Aggregation objects matching the filter parameters \"\"\" aggregations = self . _aggregations for key , value in kwargs . items (): if key . startswith ( 'file__' ): file_args = { key [ len ( 'file__' ) :]: value } aggregations = [ agg for agg in aggregations if agg . files ( ** file_args )] elif key . startswith ( 'files__' ): file_args = { key [ len ( 'files__' ) :]: value } aggregations = [ agg for agg in aggregations if agg . files ( ** file_args )] else : aggregations = filter ( lambda agg : attribute_filter ( agg . metadata , key , value ), aggregations ) return list ( aggregations ) as_series ( self , series_id , agg_path = None ) Creates a pandas Series object out of an aggregation of type TimeSeries. :param series_id: The series_id of the timeseries result to be converted to a Series object. :param agg_path: Not required. Include this parameter to avoid downloading the aggregation if you already have it downloaded locally. :return: A pandas.Series object Source code in hsclient/hydroshare.py def as_series ( self , series_id : str , agg_path : str = None ) -> Dict [ int , pandas . Series ]: \"\"\" Creates a pandas Series object out of an aggregation of type TimeSeries. :param series_id: The series_id of the timeseries result to be converted to a Series object. :param agg_path: Not required. Include this parameter to avoid downloading the aggregation if you already have it downloaded locally. :return: A pandas.Series object \"\"\" def to_series ( timeseries_file : str ): con = sqlite3 . connect ( timeseries_file ) return pandas . read_sql ( f 'SELECT * FROM TimeSeriesResultValues WHERE ResultID IN ' f '(SELECT ResultID FROM Results WHERE ResultUUID = \" { series_id } \");' , con , ) . squeeze () if agg_path is None : with tempfile . TemporaryDirectory () as td : self . _download ( unzip_to = td ) # zip extracted to folder with main file name file_name = self . file ( extension = \".sqlite\" ) . name return to_series ( urljoin ( td , file_name , file_name )) return to_series ( urljoin ( agg_path , self . file ( extension = \".sqlite\" ) . name )) file ( self , search_aggregations = False , ** kwargs ) Returns a single file in the resource that matches the filtering parameters :param search_aggregations: Defaults False, set to true to search aggregations :params **kwargs: Search by properties on the File object (path, name, extension, folder, checksum url) :return: A File object matching the filter parameters or None if no matching File was found Source code in hsclient/hydroshare.py def file ( self , search_aggregations = False , ** kwargs ) -> File : \"\"\" Returns a single file in the resource that matches the filtering parameters :param search_aggregations: Defaults False, set to true to search aggregations :params **kwargs: Search by properties on the File object (path, name, extension, folder, checksum url) :return: A File object matching the filter parameters or None if no matching File was found \"\"\" files = self . files ( search_aggregations = search_aggregations , ** kwargs ) if files : return files [ 0 ] return None files ( self , search_aggregations = False , ** kwargs ) List files and filter by properties on the file object using kwargs (i.e. extension='.txt') :param search_aggregations: Defaults False, set to true to search aggregations :params **kwargs: Search by properties on the File object (path, name, extension, folder, checksum url) :return: a List of File objects matching the filter parameters Source code in hsclient/hydroshare.py def files ( self , search_aggregations : bool = False , ** kwargs ) -> List [ File ]: \"\"\" List files and filter by properties on the file object using kwargs (i.e. extension='.txt') :param search_aggregations: Defaults False, set to true to search aggregations :params **kwargs: Search by properties on the File object (path, name, extension, folder, checksum url) :return: a List of File objects matching the filter parameters \"\"\" files = self . _files for key , value in kwargs . items (): files = list ( filter ( lambda file : attribute_filter ( file , key , value ), files )) if search_aggregations : for aggregation in self . aggregations (): files = files + list ( aggregation . files ( search_aggregations = search_aggregations , ** kwargs )) return files refresh ( self ) Forces the retrieval of the resource map and metadata files. Currently this is implemented to be lazy and will only retrieve those files again after another call to access them is made. This will be later updated to be eager and retrieve the files asynchronously. Source code in hsclient/hydroshare.py def refresh ( self ) -> None : \"\"\" Forces the retrieval of the resource map and metadata files. Currently this is implemented to be lazy and will only retrieve those files again after another call to access them is made. This will be later updated to be eager and retrieve the files asynchronously. \"\"\" # TODO, refresh should destroy the aggregation objects and async fetch everything. self . _retrieved_map = None self . _retrieved_metadata = None self . _parsed_files = None self . _parsed_aggregations = None self . _parsed_checksums = None save ( self ) Saves the metadata back to HydroShare Source code in hsclient/hydroshare.py def save ( self ) -> None : \"\"\"Saves the metadata back to HydroShare\"\"\" metadata_file = self . metadata_file metadata_string = rdf_string ( self . _retrieved_metadata , rdf_format = \"xml\" ) url = urljoin ( self . _hsapi_path , \"ingest_metadata\" ) self . _hs_session . upload_file ( url , files = { 'file' : ( metadata_file , metadata_string )}) self . refresh ()","title":"Aggregation"},{"location":"aggregation/#hsclient.hydroshare.Aggregation","text":"Represents an Aggregation in HydroShare","title":"hsclient.hydroshare.Aggregation"},{"location":"aggregation/#hsclient.hydroshare.Aggregation.main_file_path","text":"The path to the main file in the aggregation","title":"main_file_path"},{"location":"aggregation/#hsclient.hydroshare.Aggregation.metadata","text":"A metadata object for reading and updating metadata values","title":"metadata"},{"location":"aggregation/#hsclient.hydroshare.Aggregation.metadata_file","text":"The path to the metadata file","title":"metadata_file"},{"location":"aggregation/#hsclient.hydroshare.Aggregation.metadata_path","text":"The path to the metadata file","title":"metadata_path"},{"location":"aggregation/#hsclient.hydroshare.Aggregation.aggregation","text":"Returns a single Aggregation in the resource that matches the filtering parameters. Uses the same filtering rules described in the aggregations method. :params **kwargs: Search by properties on the metadata object :return: An Aggregation object matching the filter parameters or None if no matching Aggregation was found. Source code in hsclient/hydroshare.py def aggregation ( self , ** kwargs ) -> BaseMetadata : \"\"\" Returns a single Aggregation in the resource that matches the filtering parameters. Uses the same filtering rules described in the aggregations method. :params **kwargs: Search by properties on the metadata object :return: An Aggregation object matching the filter parameters or None if no matching Aggregation was found. \"\"\" aggregations = self . aggregations ( ** kwargs ) if aggregations : return aggregations [ 0 ] return None","title":"aggregation()"},{"location":"aggregation/#hsclient.hydroshare.Aggregation.aggregations","text":"List the aggregations in the resource. Filter by properties on the metadata object using kwargs. If you need to filter on nested properties, use __ (double underscore) to separate the properties. For example, to filter by the BandInformation name, call this method like aggregations(band_information__name=\"the name to search\"). :params **kwargs: Search by properties on the metadata object :return: a List of Aggregation objects matching the filter parameters Source code in hsclient/hydroshare.py def aggregations ( self , ** kwargs ) -> List [ BaseMetadata ]: \"\"\" List the aggregations in the resource. Filter by properties on the metadata object using kwargs. If you need to filter on nested properties, use __ (double underscore) to separate the properties. For example, to filter by the BandInformation name, call this method like aggregations(band_information__name=\"the name to search\"). :params **kwargs: Search by properties on the metadata object :return: a List of Aggregation objects matching the filter parameters \"\"\" aggregations = self . _aggregations for key , value in kwargs . items (): if key . startswith ( 'file__' ): file_args = { key [ len ( 'file__' ) :]: value } aggregations = [ agg for agg in aggregations if agg . files ( ** file_args )] elif key . startswith ( 'files__' ): file_args = { key [ len ( 'files__' ) :]: value } aggregations = [ agg for agg in aggregations if agg . files ( ** file_args )] else : aggregations = filter ( lambda agg : attribute_filter ( agg . metadata , key , value ), aggregations ) return list ( aggregations )","title":"aggregations()"},{"location":"aggregation/#hsclient.hydroshare.Aggregation.as_series","text":"Creates a pandas Series object out of an aggregation of type TimeSeries. :param series_id: The series_id of the timeseries result to be converted to a Series object. :param agg_path: Not required. Include this parameter to avoid downloading the aggregation if you already have it downloaded locally. :return: A pandas.Series object Source code in hsclient/hydroshare.py def as_series ( self , series_id : str , agg_path : str = None ) -> Dict [ int , pandas . Series ]: \"\"\" Creates a pandas Series object out of an aggregation of type TimeSeries. :param series_id: The series_id of the timeseries result to be converted to a Series object. :param agg_path: Not required. Include this parameter to avoid downloading the aggregation if you already have it downloaded locally. :return: A pandas.Series object \"\"\" def to_series ( timeseries_file : str ): con = sqlite3 . connect ( timeseries_file ) return pandas . read_sql ( f 'SELECT * FROM TimeSeriesResultValues WHERE ResultID IN ' f '(SELECT ResultID FROM Results WHERE ResultUUID = \" { series_id } \");' , con , ) . squeeze () if agg_path is None : with tempfile . TemporaryDirectory () as td : self . _download ( unzip_to = td ) # zip extracted to folder with main file name file_name = self . file ( extension = \".sqlite\" ) . name return to_series ( urljoin ( td , file_name , file_name )) return to_series ( urljoin ( agg_path , self . file ( extension = \".sqlite\" ) . name ))","title":"as_series()"},{"location":"aggregation/#hsclient.hydroshare.Aggregation.file","text":"Returns a single file in the resource that matches the filtering parameters :param search_aggregations: Defaults False, set to true to search aggregations :params **kwargs: Search by properties on the File object (path, name, extension, folder, checksum url) :return: A File object matching the filter parameters or None if no matching File was found Source code in hsclient/hydroshare.py def file ( self , search_aggregations = False , ** kwargs ) -> File : \"\"\" Returns a single file in the resource that matches the filtering parameters :param search_aggregations: Defaults False, set to true to search aggregations :params **kwargs: Search by properties on the File object (path, name, extension, folder, checksum url) :return: A File object matching the filter parameters or None if no matching File was found \"\"\" files = self . files ( search_aggregations = search_aggregations , ** kwargs ) if files : return files [ 0 ] return None","title":"file()"},{"location":"aggregation/#hsclient.hydroshare.Aggregation.files","text":"List files and filter by properties on the file object using kwargs (i.e. extension='.txt') :param search_aggregations: Defaults False, set to true to search aggregations :params **kwargs: Search by properties on the File object (path, name, extension, folder, checksum url) :return: a List of File objects matching the filter parameters Source code in hsclient/hydroshare.py def files ( self , search_aggregations : bool = False , ** kwargs ) -> List [ File ]: \"\"\" List files and filter by properties on the file object using kwargs (i.e. extension='.txt') :param search_aggregations: Defaults False, set to true to search aggregations :params **kwargs: Search by properties on the File object (path, name, extension, folder, checksum url) :return: a List of File objects matching the filter parameters \"\"\" files = self . _files for key , value in kwargs . items (): files = list ( filter ( lambda file : attribute_filter ( file , key , value ), files )) if search_aggregations : for aggregation in self . aggregations (): files = files + list ( aggregation . files ( search_aggregations = search_aggregations , ** kwargs )) return files","title":"files()"},{"location":"aggregation/#hsclient.hydroshare.Aggregation.refresh","text":"Forces the retrieval of the resource map and metadata files. Currently this is implemented to be lazy and will only retrieve those files again after another call to access them is made. This will be later updated to be eager and retrieve the files asynchronously. Source code in hsclient/hydroshare.py def refresh ( self ) -> None : \"\"\" Forces the retrieval of the resource map and metadata files. Currently this is implemented to be lazy and will only retrieve those files again after another call to access them is made. This will be later updated to be eager and retrieve the files asynchronously. \"\"\" # TODO, refresh should destroy the aggregation objects and async fetch everything. self . _retrieved_map = None self . _retrieved_metadata = None self . _parsed_files = None self . _parsed_aggregations = None self . _parsed_checksums = None","title":"refresh()"},{"location":"aggregation/#hsclient.hydroshare.Aggregation.save","text":"Saves the metadata back to HydroShare Source code in hsclient/hydroshare.py def save ( self ) -> None : \"\"\"Saves the metadata back to HydroShare\"\"\" metadata_file = self . metadata_file metadata_string = rdf_string ( self . _retrieved_metadata , rdf_format = \"xml\" ) url = urljoin ( self . _hsapi_path , \"ingest_metadata\" ) self . _hs_session . upload_file ( url , files = { 'file' : ( metadata_file , metadata_string )}) self . refresh ()","title":"save()"},{"location":"file/","text":"A File path string representing the path to a file within a resource. :param value: the string path value :param file_url: the fully qualified url to the file on hydroshare.org :param checksum: the md5 checksum of the file checksum property readonly The md5 checksum of the file extension : str property readonly The extension of the file folder : str property readonly The folder the file is in name : str property readonly The filename path : str property readonly The path of the file url property readonly The url to the file on HydroShare __new__ ( cls , value , file_url , checksum ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in hsclient/hydroshare.py def __new__ ( cls , value , file_url , checksum ): return super ( File , cls ) . __new__ ( cls , value )","title":"File"},{"location":"file/#hsclient.hydroshare.File","text":"A File path string representing the path to a file within a resource. :param value: the string path value :param file_url: the fully qualified url to the file on hydroshare.org :param checksum: the md5 checksum of the file","title":"hsclient.hydroshare.File"},{"location":"file/#hsclient.hydroshare.File.checksum","text":"The md5 checksum of the file","title":"checksum"},{"location":"file/#hsclient.hydroshare.File.extension","text":"The extension of the file","title":"extension"},{"location":"file/#hsclient.hydroshare.File.folder","text":"The folder the file is in","title":"folder"},{"location":"file/#hsclient.hydroshare.File.name","text":"The filename","title":"name"},{"location":"file/#hsclient.hydroshare.File.path","text":"The path of the file","title":"path"},{"location":"file/#hsclient.hydroshare.File.url","text":"The url to the file on HydroShare","title":"url"},{"location":"file/#hsclient.hydroshare.File.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in hsclient/hydroshare.py def __new__ ( cls , value , file_url , checksum ): return super ( File , cls ) . __new__ ( cls , value )","title":"__new__()"},{"location":"hydroshare/","text":"A HydroShare object for querying HydroShare's REST API. Provide a username and password at initialization or call the sign_in() method to prompt for the username and password. If using OAuth2 is desired, provide the client_id and token to use. If on CUAHSI JupyterHub or another JupyterHub environment that authenticates with Hydroshare, call the hs_juptyerhub() method to read the credentials from Jupyterhub. :param username: A HydroShare username :param password: A HydroShare password associated with the username :param host: The host to use, defaults to www.hydroshare.org :param protocol: The protocol to use, defaults to https :param port: The port to use, defaults to 443 :param client_id: The client id associated with the OAuth2 token :param token: The OAuth2 token to use create ( self ) Creates a new resource on HydroShare :return: A Resource object representing a resource on HydroShare Source code in hsclient/hydroshare.py def create ( self ) -> Resource : \"\"\" Creates a new resource on HydroShare :return: A Resource object representing a resource on HydroShare \"\"\" response = self . _hs_session . post ( '/hsapi/resource/' , status_code = 201 ) resource_id = response . json ()[ 'resource_id' ] return self . resource ( resource_id ) hs_juptyerhub ( self , hs_auth_path = '/home/jovyan/data/.hs_auth' ) Reads the OAuth2 client id and token from a Jupyterhub which uses HydroShare for authentication :param hs_auth_path: Provide the path to the .hs_auth file if different than the default of /home/jovyan/data/.hs_auth Source code in hsclient/hydroshare.py def hs_juptyerhub ( self , hs_auth_path = \"/home/jovyan/data/.hs_auth\" ): \"\"\" Reads the OAuth2 client id and token from a Jupyterhub which uses HydroShare for authentication :param hs_auth_path: Provide the path to the .hs_auth file if different than the default of `/home/jovyan/data/.hs_auth` \"\"\" if not os . path . isfile ( hs_auth_path ): raise ValueError ( f \"hs_auth_path { hs_auth_path } does not exist.\" ) with open ( hs_auth_path , 'rb' ) as f : token , client_id = pickle . load ( f ) self . _hs_session . set_oauth ( client_id , token ) self . my_user_info () # validate credentials my_user_info ( self ) Retrieves the user info of the user's credentials provided :return: JSON object representing the user info Source code in hsclient/hydroshare.py def my_user_info ( self ): \"\"\" Retrieves the user info of the user's credentials provided :return: JSON object representing the user info \"\"\" response = self . _hs_session . get ( '/hsapi/userInfo/' , status_code = 200 ) return response . json () resource ( self , resource_id , validate = True ) Creates a resource object from HydroShare with the provided resource_id :param resource_id: The resource id of the resource to retrieve :param validate: Defaults to True, set to False to not validate the resource exists :return: A Resource object representing a resource on HydroShare Source code in hsclient/hydroshare.py def resource ( self , resource_id : str , validate : bool = True ) -> Resource : \"\"\" Creates a resource object from HydroShare with the provided resource_id :param resource_id: The resource id of the resource to retrieve :param validate: Defaults to True, set to False to not validate the resource exists :return: A Resource object representing a resource on HydroShare \"\"\" res = Resource ( \"/resource/ {} /data/resourcemap.xml\" . format ( resource_id ), self . _hs_session ) if validate : res . metadata return res search ( self , creator = None , contributor = None , owner = None , group_name = None , from_date = None , to_date = None , edit_permission = False , resource_types = [], subject = [], full_text_search = None , published = False , spatial_coverage = None ) Query the GET /hsapi/resource/ REST end point of the HydroShare server. :param creator: Filter results by the HydroShare username or email :param author: Filter results by the HydroShare username or email :param owner: Filter results by the HydroShare username or email :param group_name: Filter results by the HydroShare group name associated with resources :param from_date: Filter results to those created after from_date. Must be datetime.date. :param to_date: Filter results to those created before to_date. Must be datetime.date. Because dates have no time information, you must specify date+1 day to get results for date (e.g. use 2015-05-06 to get resources created up to and including 2015-05-05) :param types: Filter results to particular HydroShare resource types (Deprecated, all types are Composite) :param subject: Filter by comma separated list of subjects :param full_text_search: Filter by full text search :param edit_permission: Filter by boolean edit permission :param published: Filter by boolean published status :param spatial_coverage: Filtering by spatial coverage raises a 500, do not use :return: A generator to iterate over a ResourcePreview object Source code in hsclient/hydroshare.py def search ( self , creator : str = None , contributor : str = None , owner : str = None , group_name : str = None , from_date : datetime = None , to_date : datetime = None , edit_permission : bool = False , resource_types : List [ str ] = [], subject : List [ str ] = [], full_text_search : str = None , published : bool = False , spatial_coverage : Union [ BoxCoverage , PointCoverage ] = None , ): \"\"\" Query the GET /hsapi/resource/ REST end point of the HydroShare server. :param creator: Filter results by the HydroShare username or email :param author: Filter results by the HydroShare username or email :param owner: Filter results by the HydroShare username or email :param group_name: Filter results by the HydroShare group name associated with resources :param from_date: Filter results to those created after from_date. Must be datetime.date. :param to_date: Filter results to those created before to_date. Must be datetime.date. Because dates have no time information, you must specify date+1 day to get results for date (e.g. use 2015-05-06 to get resources created up to and including 2015-05-05) :param types: Filter results to particular HydroShare resource types (Deprecated, all types are Composite) :param subject: Filter by comma separated list of subjects :param full_text_search: Filter by full text search :param edit_permission: Filter by boolean edit permission :param published: Filter by boolean published status :param spatial_coverage: Filtering by spatial coverage raises a 500, do not use :return: A generator to iterate over a ResourcePreview object \"\"\" params = { \"edit_permission\" : edit_permission , \"published\" : published } if creator : params [ \"creator\" ] = creator if contributor : params [ \"author\" ] = contributor if owner : params [ \"owner\" ] = owner if group_name : params [ \"group\" ] = group_name if resource_types : params [ \"type[]\" ] = resource_types if subject : params [ \"subject\" ] = \",\" . join ( subject ) if full_text_search : params [ \"full_text_search\" ] = full_text_search if from_date : params [ \"from_date\" ] = from_date . strftime ( '%Y-%m- %d ' ) if to_date : params [ \"to_date\" ] = to_date . strftime ( '%Y-%m- %d ' ) if spatial_coverage : params [ \"coverage_type\" ] = spatial_coverage . type if spatial_coverage . type == \"point\" : params [ \"north\" ] = spatial_coverage . north params [ \"east\" ] = spatial_coverage . east else : params [ \"north\" ] = spatial_coverage . northlimit params [ \"east\" ] = spatial_coverage . eastlimit params [ \"south\" ] = spatial_coverage . southlimit params [ \"west\" ] = spatial_coverage . westlimit response = self . _hs_session . get ( \"/hsapi/resource/\" , 200 , params = params ) res = response . json () results = res [ 'results' ] print ( res [ 'count' ]) for item in results : yield ResourcePreview ( ** item ) while res [ 'next' ]: next_url = res [ 'next' ] next_url = urlparse ( next_url ) path = next_url . path params = next_url . query response = self . _hs_session . get ( path , 200 , params = params ) res = response . json () results = res [ 'results' ] for item in results : yield ResourcePreview ( ** item ) sign_in ( self ) Prompts for username/password. Useful for avoiding saving your HydroShare credentials to a notebook Source code in hsclient/hydroshare.py def sign_in ( self ) -> None : \"\"\"Prompts for username/password. Useful for avoiding saving your HydroShare credentials to a notebook\"\"\" username = input ( \"Username: \" ) . strip () password = getpass . getpass ( \"Password for {} : \" . format ( username )) self . _hs_session . set_auth (( username , password )) self . my_user_info () # validate credentials user ( self , user_id ) Retrieves the user details of a Hydroshare user :param user_id: The user id of the user details to retrieve :return: User object representing the user details Source code in hsclient/hydroshare.py def user ( self , user_id : int ) -> User : \"\"\" Retrieves the user details of a Hydroshare user :param user_id: The user id of the user details to retrieve :return: User object representing the user details \"\"\" response = self . _hs_session . get ( f '/hsapi/userDetails/ { user_id } /' , status_code = 200 ) return User ( ** response . json ())","title":"Hydroshare"},{"location":"hydroshare/#hsclient.hydroshare.HydroShare","text":"A HydroShare object for querying HydroShare's REST API. Provide a username and password at initialization or call the sign_in() method to prompt for the username and password. If using OAuth2 is desired, provide the client_id and token to use. If on CUAHSI JupyterHub or another JupyterHub environment that authenticates with Hydroshare, call the hs_juptyerhub() method to read the credentials from Jupyterhub. :param username: A HydroShare username :param password: A HydroShare password associated with the username :param host: The host to use, defaults to www.hydroshare.org :param protocol: The protocol to use, defaults to https :param port: The port to use, defaults to 443 :param client_id: The client id associated with the OAuth2 token :param token: The OAuth2 token to use","title":"hsclient.hydroshare.HydroShare"},{"location":"hydroshare/#hsclient.hydroshare.HydroShare.create","text":"Creates a new resource on HydroShare :return: A Resource object representing a resource on HydroShare Source code in hsclient/hydroshare.py def create ( self ) -> Resource : \"\"\" Creates a new resource on HydroShare :return: A Resource object representing a resource on HydroShare \"\"\" response = self . _hs_session . post ( '/hsapi/resource/' , status_code = 201 ) resource_id = response . json ()[ 'resource_id' ] return self . resource ( resource_id )","title":"create()"},{"location":"hydroshare/#hsclient.hydroshare.HydroShare.hs_juptyerhub","text":"Reads the OAuth2 client id and token from a Jupyterhub which uses HydroShare for authentication :param hs_auth_path: Provide the path to the .hs_auth file if different than the default of /home/jovyan/data/.hs_auth Source code in hsclient/hydroshare.py def hs_juptyerhub ( self , hs_auth_path = \"/home/jovyan/data/.hs_auth\" ): \"\"\" Reads the OAuth2 client id and token from a Jupyterhub which uses HydroShare for authentication :param hs_auth_path: Provide the path to the .hs_auth file if different than the default of `/home/jovyan/data/.hs_auth` \"\"\" if not os . path . isfile ( hs_auth_path ): raise ValueError ( f \"hs_auth_path { hs_auth_path } does not exist.\" ) with open ( hs_auth_path , 'rb' ) as f : token , client_id = pickle . load ( f ) self . _hs_session . set_oauth ( client_id , token ) self . my_user_info () # validate credentials","title":"hs_juptyerhub()"},{"location":"hydroshare/#hsclient.hydroshare.HydroShare.my_user_info","text":"Retrieves the user info of the user's credentials provided :return: JSON object representing the user info Source code in hsclient/hydroshare.py def my_user_info ( self ): \"\"\" Retrieves the user info of the user's credentials provided :return: JSON object representing the user info \"\"\" response = self . _hs_session . get ( '/hsapi/userInfo/' , status_code = 200 ) return response . json ()","title":"my_user_info()"},{"location":"hydroshare/#hsclient.hydroshare.HydroShare.resource","text":"Creates a resource object from HydroShare with the provided resource_id :param resource_id: The resource id of the resource to retrieve :param validate: Defaults to True, set to False to not validate the resource exists :return: A Resource object representing a resource on HydroShare Source code in hsclient/hydroshare.py def resource ( self , resource_id : str , validate : bool = True ) -> Resource : \"\"\" Creates a resource object from HydroShare with the provided resource_id :param resource_id: The resource id of the resource to retrieve :param validate: Defaults to True, set to False to not validate the resource exists :return: A Resource object representing a resource on HydroShare \"\"\" res = Resource ( \"/resource/ {} /data/resourcemap.xml\" . format ( resource_id ), self . _hs_session ) if validate : res . metadata return res","title":"resource()"},{"location":"hydroshare/#hsclient.hydroshare.HydroShare.search","text":"Query the GET /hsapi/resource/ REST end point of the HydroShare server. :param creator: Filter results by the HydroShare username or email :param author: Filter results by the HydroShare username or email :param owner: Filter results by the HydroShare username or email :param group_name: Filter results by the HydroShare group name associated with resources :param from_date: Filter results to those created after from_date. Must be datetime.date. :param to_date: Filter results to those created before to_date. Must be datetime.date. Because dates have no time information, you must specify date+1 day to get results for date (e.g. use 2015-05-06 to get resources created up to and including 2015-05-05) :param types: Filter results to particular HydroShare resource types (Deprecated, all types are Composite) :param subject: Filter by comma separated list of subjects :param full_text_search: Filter by full text search :param edit_permission: Filter by boolean edit permission :param published: Filter by boolean published status :param spatial_coverage: Filtering by spatial coverage raises a 500, do not use :return: A generator to iterate over a ResourcePreview object Source code in hsclient/hydroshare.py def search ( self , creator : str = None , contributor : str = None , owner : str = None , group_name : str = None , from_date : datetime = None , to_date : datetime = None , edit_permission : bool = False , resource_types : List [ str ] = [], subject : List [ str ] = [], full_text_search : str = None , published : bool = False , spatial_coverage : Union [ BoxCoverage , PointCoverage ] = None , ): \"\"\" Query the GET /hsapi/resource/ REST end point of the HydroShare server. :param creator: Filter results by the HydroShare username or email :param author: Filter results by the HydroShare username or email :param owner: Filter results by the HydroShare username or email :param group_name: Filter results by the HydroShare group name associated with resources :param from_date: Filter results to those created after from_date. Must be datetime.date. :param to_date: Filter results to those created before to_date. Must be datetime.date. Because dates have no time information, you must specify date+1 day to get results for date (e.g. use 2015-05-06 to get resources created up to and including 2015-05-05) :param types: Filter results to particular HydroShare resource types (Deprecated, all types are Composite) :param subject: Filter by comma separated list of subjects :param full_text_search: Filter by full text search :param edit_permission: Filter by boolean edit permission :param published: Filter by boolean published status :param spatial_coverage: Filtering by spatial coverage raises a 500, do not use :return: A generator to iterate over a ResourcePreview object \"\"\" params = { \"edit_permission\" : edit_permission , \"published\" : published } if creator : params [ \"creator\" ] = creator if contributor : params [ \"author\" ] = contributor if owner : params [ \"owner\" ] = owner if group_name : params [ \"group\" ] = group_name if resource_types : params [ \"type[]\" ] = resource_types if subject : params [ \"subject\" ] = \",\" . join ( subject ) if full_text_search : params [ \"full_text_search\" ] = full_text_search if from_date : params [ \"from_date\" ] = from_date . strftime ( '%Y-%m- %d ' ) if to_date : params [ \"to_date\" ] = to_date . strftime ( '%Y-%m- %d ' ) if spatial_coverage : params [ \"coverage_type\" ] = spatial_coverage . type if spatial_coverage . type == \"point\" : params [ \"north\" ] = spatial_coverage . north params [ \"east\" ] = spatial_coverage . east else : params [ \"north\" ] = spatial_coverage . northlimit params [ \"east\" ] = spatial_coverage . eastlimit params [ \"south\" ] = spatial_coverage . southlimit params [ \"west\" ] = spatial_coverage . westlimit response = self . _hs_session . get ( \"/hsapi/resource/\" , 200 , params = params ) res = response . json () results = res [ 'results' ] print ( res [ 'count' ]) for item in results : yield ResourcePreview ( ** item ) while res [ 'next' ]: next_url = res [ 'next' ] next_url = urlparse ( next_url ) path = next_url . path params = next_url . query response = self . _hs_session . get ( path , 200 , params = params ) res = response . json () results = res [ 'results' ] for item in results : yield ResourcePreview ( ** item )","title":"search()"},{"location":"hydroshare/#hsclient.hydroshare.HydroShare.sign_in","text":"Prompts for username/password. Useful for avoiding saving your HydroShare credentials to a notebook Source code in hsclient/hydroshare.py def sign_in ( self ) -> None : \"\"\"Prompts for username/password. Useful for avoiding saving your HydroShare credentials to a notebook\"\"\" username = input ( \"Username: \" ) . strip () password = getpass . getpass ( \"Password for {} : \" . format ( username )) self . _hs_session . set_auth (( username , password )) self . my_user_info () # validate credentials","title":"sign_in()"},{"location":"hydroshare/#hsclient.hydroshare.HydroShare.user","text":"Retrieves the user details of a Hydroshare user :param user_id: The user id of the user details to retrieve :return: User object representing the user details Source code in hsclient/hydroshare.py def user ( self , user_id : int ) -> User : \"\"\" Retrieves the user details of a Hydroshare user :param user_id: The user id of the user details to retrieve :return: User object representing the user details \"\"\" response = self . _hs_session . get ( f '/hsapi/userDetails/ { user_id } /' , status_code = 200 ) return User ( ** response . json ())","title":"user()"},{"location":"resource/","text":"Represents a Resource in HydroShare access_permission property readonly Retrieves the access permissions of the resource :return: JSON object resource_id : str property readonly The resource id (guid) of the HydroShare resource aggregation_delete ( self , aggregation ) Deletes an aggregation from HydroShare. This deletes the files and metadata in the aggregation. :param aggregation: The aggregation object to delete Source code in hsclient/hydroshare.py def aggregation_delete ( self , aggregation : Aggregation ) -> None : \"\"\" Deletes an aggregation from HydroShare. This deletes the files and metadata in the aggregation. :param aggregation: The aggregation object to delete \"\"\" path = urljoin ( aggregation . _hsapi_path , \"functions\" , \"delete-file-type\" , aggregation . metadata . type . value + \"LogicalFile\" , aggregation . main_file_path , ) aggregation . _hs_session . delete ( path , status_code = 200 ) aggregation . refresh () self . refresh () aggregation_download ( self , aggregation , save_path = '' , unzip_to = None ) Download an aggregation from HydroShare :param aggregation: The aggreation to download :param save_path: The local path to save the aggregation to, defaults to the current directory :param unzip_to: If set, the resulting download will be unzipped to the specified path Source code in hsclient/hydroshare.py def aggregation_download ( self , aggregation : Aggregation , save_path : str = \"\" , unzip_to : str = None ) -> str : \"\"\" Download an aggregation from HydroShare :param aggregation: The aggreation to download :param save_path: The local path to save the aggregation to, defaults to the current directory :param unzip_to: If set, the resulting download will be unzipped to the specified path \"\"\" return aggregation . _download ( save_path = save_path , unzip_to = unzip_to ) aggregation_remove ( self , aggregation ) Removes an aggregation from HydroShare. This does not remove the files in the aggregation. :param aggregation: The aggregation object to remove Source code in hsclient/hydroshare.py def aggregation_remove ( self , aggregation : Aggregation ) -> None : \"\"\" Removes an aggregation from HydroShare. This does not remove the files in the aggregation. :param aggregation: The aggregation object to remove \"\"\" path = urljoin ( aggregation . _hsapi_path , \"functions\" , \"remove-file-type\" , aggregation . metadata . type . value + \"LogicalFile\" , aggregation . main_file_path , ) aggregation . _hs_session . post ( path , status_code = 200 ) aggregation . refresh () self . refresh () copy ( self ) Copies this Resource into a new resource on HydroShare returns: A Resource object of the newly copied resource Source code in hsclient/hydroshare.py def copy ( self ): \"\"\" Copies this Resource into a new resource on HydroShare returns: A Resource object of the newly copied resource \"\"\" path = urljoin ( self . _hsapi_path , \"copy\" ) response = self . _hs_session . post ( path , status_code = 202 ) resource_id = response . text return Resource ( \"/resource/ {} /data/resourcemap.xml\" . format ( resource_id ), self . _hs_session ) delete ( self ) Deletes the resource on HydroShare Source code in hsclient/hydroshare.py def delete ( self ) -> None : \"\"\"Deletes the resource on HydroShare\"\"\" hsapi_path = self . _hsapi_path self . _hs_session . delete ( hsapi_path , status_code = 204 ) self . refresh () download ( self , save_path = '' ) Downloads a zipped bagit archive of the resource from HydroShare param save_path: A local path to save the bag to, defaults to the current working directory returns: The relative pathname of the download Source code in hsclient/hydroshare.py def download ( self , save_path : str = \"\" ) -> str : \"\"\" Downloads a zipped bagit archive of the resource from HydroShare param save_path: A local path to save the bag to, defaults to the current working directory returns: The relative pathname of the download \"\"\" return self . _hs_session . retrieve_bag ( self . _hsapi_path , save_path = save_path ) file_aggregate ( self , path , agg_type ) Aggregate a file to a HydroShare aggregation type. Aggregating files allows you to specify metadata specific to the files associated with the aggregation. To set a FileSet aggregation, include the path to the folder or a file in the folder you would like to create a FileSet aggregation from. :param path: The path to the file to aggregate :param agg_type: The AggregationType to create :returns: The newly created Aggregation object Source code in hsclient/hydroshare.py def file_aggregate ( self , path , agg_type : AggregationType ): \"\"\" Aggregate a file to a HydroShare aggregation type. Aggregating files allows you to specify metadata specific to the files associated with the aggregation. To set a FileSet aggregation, include the path to the folder or a file in the folder you would like to create a FileSet aggregation from. :param path: The path to the file to aggregate :param agg_type: The AggregationType to create :returns: The newly created Aggregation object \"\"\" type_value = agg_type . value data = {} if agg_type == AggregationType . SingleFileAggregation : type_value = 'SingleFile' if agg_type == AggregationType . FileSetAggregation : relative_path = dirname ( path ) data = { \"folder_path\" : relative_path } url = urljoin ( self . _hsapi_path , \"functions\" , \"set-file-type\" , path , type_value ) self . _hs_session . post ( url , status_code = 201 , data = data ) self . refresh () return self . aggregation ( file__path = path ) file_delete ( self , path = None ) Delete a file on HydroShare :param path: The path to the file Source code in hsclient/hydroshare.py def file_delete ( self , path : str = None ) -> None : \"\"\" Delete a file on HydroShare :param path: The path to the file \"\"\" self . _delete_file ( path ) self . refresh () file_download ( self , path , save_path = '' , zipped = False ) Downloads a file from HydroShare :param path: The path to the file :param save_path: The local path to save the file to :param zipped: Defaults to False, set to True to download the file zipped :returns: The path to the downloaded file Source code in hsclient/hydroshare.py def file_download ( self , path : str , save_path : str = \"\" , zipped : bool = False ): \"\"\" Downloads a file from HydroShare :param path: The path to the file :param save_path: The local path to save the file to :param zipped: Defaults to False, set to True to download the file zipped :returns: The path to the downloaded file \"\"\" if zipped : return self . _hs_session . retrieve_zip ( urljoin ( self . _resource_path , \"data\" , \"contents\" , path ), save_path , params = { \"zipped\" : \"true\" } ) else : return self . _hs_session . retrieve_file ( urljoin ( self . _resource_path , \"data\" , \"contents\" , path ), save_path ) file_rename ( self , path , new_path ) Rename a file on HydroShare :param path: The path to the file :param new_path: the renamed path to the file Source code in hsclient/hydroshare.py def file_rename ( self , path : str , new_path : str ) -> None : \"\"\" Rename a file on HydroShare :param path: The path to the file :param new_path: the renamed path to the file \"\"\" rename_path = urljoin ( self . _hsapi_path , \"functions\" , \"move-or-rename\" ) self . _hs_session . post ( rename_path , status_code = 200 , data = { \"source_path\" : path , \"target_path\" : new_path }) self . refresh () file_unzip ( self , path ) Unzips a file on HydroShare :param path: The path to the file to unzip Source code in hsclient/hydroshare.py def file_unzip ( self , path : str ) -> None : \"\"\" Unzips a file on HydroShare :param path: The path to the file to unzip \"\"\" if not path . endswith ( \".zip\" ): raise Exception ( \"File {} is not a zip, and cannot be unzipped\" . format ( path )) unzip_path = urljoin ( self . _hsapi_path , \"functions\" , \"unzip\" , \"data\" , \"contents\" , path ) self . _hs_session . post ( unzip_path , status_code = 200 , data = { \"overwrite\" : \"true\" , \"ingest_metadata\" : \"true\" }) self . refresh () file_upload ( self , * files , * , destination_path = '' ) Uploads files to a folder in HydroShare :param *files: The local file paths to upload :param destination_path: The path on HydroShare to upload the files to, defaults to the root contents directory Source code in hsclient/hydroshare.py def file_upload ( self , * files : str , destination_path : str = \"\" ) -> None : \"\"\" Uploads files to a folder in HydroShare :param *files: The local file paths to upload :param destination_path: The path on HydroShare to upload the files to, defaults to the root contents directory \"\"\" if len ( files ) == 1 : self . _upload ( files [ 0 ], destination_path = destination_path ) else : with tempfile . TemporaryDirectory () as tmpdir : zipped_file = urljoin ( tmpdir , 'files.zip' ) with ZipFile ( urljoin ( tmpdir , zipped_file ), 'w' ) as zipped : for file in files : zipped . write ( file , basename ( file )) self . _upload ( zipped_file , destination_path = destination_path ) unzip_path = urljoin ( self . _hsapi_path , \"functions\" , \"unzip\" , \"data\" , \"contents\" , destination_path , 'files.zip' ) self . _hs_session . post ( unzip_path , status_code = 200 , data = { \"overwrite\" : \"true\" , \"ingest_metadata\" : \"true\" } ) self . refresh () file_zip ( self , path , zip_name = None , remove_file = True ) Zip a file on HydroShare :param path: The path to the file :param zip_name: The name of the zipped file :param remove_file: Defaults to True, set to False to not delete the file that was zipped Source code in hsclient/hydroshare.py def file_zip ( self , path : str , zip_name : str = None , remove_file : bool = True ) -> None : \"\"\" Zip a file on HydroShare :param path: The path to the file :param zip_name: The name of the zipped file :param remove_file: Defaults to True, set to False to not delete the file that was zipped \"\"\" zip_name = basename ( path ) + \".zip\" if not zip_name else zip_name data = { \"input_coll_path\" : path , \"output_zip_file_name\" : zip_name , \"remove_original_after_zip\" : remove_file } zip_path = urljoin ( self . _hsapi_path , \"functions\" , \"zip\" ) self . _hs_session . post ( zip_path , status_code = 200 , data = data ) self . refresh () folder_create ( self , folder ) Creates a folder on HydroShare :param folder: the folder path to create Source code in hsclient/hydroshare.py def folder_create ( self , folder : str ) -> None : \"\"\" Creates a folder on HydroShare :param folder: the folder path to create \"\"\" path = urljoin ( self . _hsapi_path , \"folders\" , folder ) self . _hs_session . put ( path , status_code = 201 ) folder_delete ( self , path = None ) Deletes a folder on HydroShare :param path: the path to the folder Source code in hsclient/hydroshare.py def folder_delete ( self , path : str = None ) -> None : \"\"\" Deletes a folder on HydroShare :param path: the path to the folder \"\"\" self . _delete_file_folder ( path ) self . refresh () folder_download ( self , path , save_path = '' ) Downloads a folder from HydroShare :param path: The path to folder :param save_path: The local path to save the download to, defaults to the current directory :returns: The path to the download zipped folder Source code in hsclient/hydroshare.py def folder_download ( self , path : str , save_path : str = \"\" ): \"\"\" Downloads a folder from HydroShare :param path: The path to folder :param save_path: The local path to save the download to, defaults to the current directory :returns: The path to the download zipped folder \"\"\" return self . _hs_session . retrieve_zip ( urljoin ( self . _resource_path , \"data\" , \"contents\" , path ), save_path , params = { \"zipped\" : \"true\" } ) folder_rename ( self , path , new_path ) Renames a folder on HydroShare :param path: the path to the folder to rename :param new_path: the new path folder name Source code in hsclient/hydroshare.py def folder_rename ( self , path : str , new_path : str ) -> None : \"\"\" Renames a folder on HydroShare :param path: the path to the folder to rename :param new_path: the new path folder name \"\"\" self . file_rename ( path = path , new_path = new_path ) new_version ( self ) Creates a new version of the resource on HydroShare :return: A Resource object of the newly created resource version Source code in hsclient/hydroshare.py def new_version ( self ): \"\"\" Creates a new version of the resource on HydroShare :return: A Resource object of the newly created resource version \"\"\" path = urljoin ( self . _hsapi_path , \"version\" ) response = self . _hs_session . post ( path , status_code = 202 ) resource_id = response . text return Resource ( \"/resource/ {} /data/resourcemap.xml\" . format ( resource_id ), self . _hs_session ) reference_create ( self , file_name , url , path = '' ) Creates a HydroShare reference object to reference content outside of the resource :param file_name: the file name of the resulting .url file :param url: the url of the referenced content :param path: the path to create the reference in Source code in hsclient/hydroshare.py def reference_create ( self , file_name : str , url : str , path : str = '' ) -> None : \"\"\" Creates a HydroShare reference object to reference content outside of the resource :param file_name: the file name of the resulting .url file :param url: the url of the referenced content :param path: the path to create the reference in \"\"\" request_path = urljoin ( self . _hsapi_path . replace ( self . resource_id , \"\" ), \"data-store-add-reference\" ) self . _hs_session . post ( request_path , data = { \"res_id\" : self . resource_id , \"curr_path\" : path , \"ref_name\" : file_name , \"ref_url\" : url }, status_code = 200 , ) self . refresh () reference_update ( self , file_name , url , path = '' ) Updates a HydroShare reference object :param file_name: the file name for the .url file :param url: the url of the referenced content :param path: the path to the directory where the reference is located Source code in hsclient/hydroshare.py def reference_update ( self , file_name : str , url : str , path : str = '' ) -> None : \"\"\" Updates a HydroShare reference object :param file_name: the file name for the .url file :param url: the url of the referenced content :param path: the path to the directory where the reference is located \"\"\" request_path = urljoin ( self . _hsapi_path . replace ( self . resource_id , \"\" ), \"data_store_edit_reference_url\" ) self . _hs_session . post ( request_path , data = { \"res_id\" : self . resource_id , \"curr_path\" : path , \"url_filename\" : file_name , \"new_ref_url\" : url }, status_code = 200 , ) self . refresh () save ( self ) Saves the metadata to HydroShare Source code in hsclient/hydroshare.py def save ( self ) -> None : \"\"\"Saves the metadata to HydroShare\"\"\" metadata_string = rdf_string ( self . _retrieved_metadata , rdf_format = \"xml\" ) path = urljoin ( self . _hsapi_path , \"ingest_metadata\" ) self . _hs_session . upload_file ( path , files = { 'file' : ( 'resourcemetadata.xml' , metadata_string )}) self . refresh () set_sharing_status ( self , public ) Set the sharing status of the resource to public or private :param public: bool, set to True for public, False for private Source code in hsclient/hydroshare.py def set_sharing_status ( self , public : bool ): \"\"\" Set the sharing status of the resource to public or private :param public: bool, set to True for public, False for private \"\"\" path = urljoin ( \"hsapi\" , \"resource\" , \"accessRules\" , self . resource_id ) data = { 'public' : public } self . _hs_session . put ( path , status_code = 200 , data = data ) system_metadata ( self ) The system metadata associated with the HydroShare resource returns: JSON object Source code in hsclient/hydroshare.py def system_metadata ( self ): \"\"\" The system metadata associated with the HydroShare resource returns: JSON object \"\"\" hsapi_path = urljoin ( self . _hsapi_path , 'sysmeta' ) return self . _hs_session . get ( hsapi_path , status_code = 200 ) . json ()","title":"Resource"},{"location":"resource/#hsclient.hydroshare.Resource","text":"Represents a Resource in HydroShare","title":"hsclient.hydroshare.Resource"},{"location":"resource/#hsclient.hydroshare.Resource.access_permission","text":"Retrieves the access permissions of the resource :return: JSON object","title":"access_permission"},{"location":"resource/#hsclient.hydroshare.Resource.resource_id","text":"The resource id (guid) of the HydroShare resource","title":"resource_id"},{"location":"resource/#hsclient.hydroshare.Resource.aggregation_delete","text":"Deletes an aggregation from HydroShare. This deletes the files and metadata in the aggregation. :param aggregation: The aggregation object to delete Source code in hsclient/hydroshare.py def aggregation_delete ( self , aggregation : Aggregation ) -> None : \"\"\" Deletes an aggregation from HydroShare. This deletes the files and metadata in the aggregation. :param aggregation: The aggregation object to delete \"\"\" path = urljoin ( aggregation . _hsapi_path , \"functions\" , \"delete-file-type\" , aggregation . metadata . type . value + \"LogicalFile\" , aggregation . main_file_path , ) aggregation . _hs_session . delete ( path , status_code = 200 ) aggregation . refresh () self . refresh ()","title":"aggregation_delete()"},{"location":"resource/#hsclient.hydroshare.Resource.aggregation_download","text":"Download an aggregation from HydroShare :param aggregation: The aggreation to download :param save_path: The local path to save the aggregation to, defaults to the current directory :param unzip_to: If set, the resulting download will be unzipped to the specified path Source code in hsclient/hydroshare.py def aggregation_download ( self , aggregation : Aggregation , save_path : str = \"\" , unzip_to : str = None ) -> str : \"\"\" Download an aggregation from HydroShare :param aggregation: The aggreation to download :param save_path: The local path to save the aggregation to, defaults to the current directory :param unzip_to: If set, the resulting download will be unzipped to the specified path \"\"\" return aggregation . _download ( save_path = save_path , unzip_to = unzip_to )","title":"aggregation_download()"},{"location":"resource/#hsclient.hydroshare.Resource.aggregation_remove","text":"Removes an aggregation from HydroShare. This does not remove the files in the aggregation. :param aggregation: The aggregation object to remove Source code in hsclient/hydroshare.py def aggregation_remove ( self , aggregation : Aggregation ) -> None : \"\"\" Removes an aggregation from HydroShare. This does not remove the files in the aggregation. :param aggregation: The aggregation object to remove \"\"\" path = urljoin ( aggregation . _hsapi_path , \"functions\" , \"remove-file-type\" , aggregation . metadata . type . value + \"LogicalFile\" , aggregation . main_file_path , ) aggregation . _hs_session . post ( path , status_code = 200 ) aggregation . refresh () self . refresh ()","title":"aggregation_remove()"},{"location":"resource/#hsclient.hydroshare.Resource.copy","text":"Copies this Resource into a new resource on HydroShare returns: A Resource object of the newly copied resource Source code in hsclient/hydroshare.py def copy ( self ): \"\"\" Copies this Resource into a new resource on HydroShare returns: A Resource object of the newly copied resource \"\"\" path = urljoin ( self . _hsapi_path , \"copy\" ) response = self . _hs_session . post ( path , status_code = 202 ) resource_id = response . text return Resource ( \"/resource/ {} /data/resourcemap.xml\" . format ( resource_id ), self . _hs_session )","title":"copy()"},{"location":"resource/#hsclient.hydroshare.Resource.delete","text":"Deletes the resource on HydroShare Source code in hsclient/hydroshare.py def delete ( self ) -> None : \"\"\"Deletes the resource on HydroShare\"\"\" hsapi_path = self . _hsapi_path self . _hs_session . delete ( hsapi_path , status_code = 204 ) self . refresh ()","title":"delete()"},{"location":"resource/#hsclient.hydroshare.Resource.download","text":"Downloads a zipped bagit archive of the resource from HydroShare param save_path: A local path to save the bag to, defaults to the current working directory returns: The relative pathname of the download Source code in hsclient/hydroshare.py def download ( self , save_path : str = \"\" ) -> str : \"\"\" Downloads a zipped bagit archive of the resource from HydroShare param save_path: A local path to save the bag to, defaults to the current working directory returns: The relative pathname of the download \"\"\" return self . _hs_session . retrieve_bag ( self . _hsapi_path , save_path = save_path )","title":"download()"},{"location":"resource/#hsclient.hydroshare.Resource.file_aggregate","text":"Aggregate a file to a HydroShare aggregation type. Aggregating files allows you to specify metadata specific to the files associated with the aggregation. To set a FileSet aggregation, include the path to the folder or a file in the folder you would like to create a FileSet aggregation from. :param path: The path to the file to aggregate :param agg_type: The AggregationType to create :returns: The newly created Aggregation object Source code in hsclient/hydroshare.py def file_aggregate ( self , path , agg_type : AggregationType ): \"\"\" Aggregate a file to a HydroShare aggregation type. Aggregating files allows you to specify metadata specific to the files associated with the aggregation. To set a FileSet aggregation, include the path to the folder or a file in the folder you would like to create a FileSet aggregation from. :param path: The path to the file to aggregate :param agg_type: The AggregationType to create :returns: The newly created Aggregation object \"\"\" type_value = agg_type . value data = {} if agg_type == AggregationType . SingleFileAggregation : type_value = 'SingleFile' if agg_type == AggregationType . FileSetAggregation : relative_path = dirname ( path ) data = { \"folder_path\" : relative_path } url = urljoin ( self . _hsapi_path , \"functions\" , \"set-file-type\" , path , type_value ) self . _hs_session . post ( url , status_code = 201 , data = data ) self . refresh () return self . aggregation ( file__path = path )","title":"file_aggregate()"},{"location":"resource/#hsclient.hydroshare.Resource.file_delete","text":"Delete a file on HydroShare :param path: The path to the file Source code in hsclient/hydroshare.py def file_delete ( self , path : str = None ) -> None : \"\"\" Delete a file on HydroShare :param path: The path to the file \"\"\" self . _delete_file ( path ) self . refresh ()","title":"file_delete()"},{"location":"resource/#hsclient.hydroshare.Resource.file_download","text":"Downloads a file from HydroShare :param path: The path to the file :param save_path: The local path to save the file to :param zipped: Defaults to False, set to True to download the file zipped :returns: The path to the downloaded file Source code in hsclient/hydroshare.py def file_download ( self , path : str , save_path : str = \"\" , zipped : bool = False ): \"\"\" Downloads a file from HydroShare :param path: The path to the file :param save_path: The local path to save the file to :param zipped: Defaults to False, set to True to download the file zipped :returns: The path to the downloaded file \"\"\" if zipped : return self . _hs_session . retrieve_zip ( urljoin ( self . _resource_path , \"data\" , \"contents\" , path ), save_path , params = { \"zipped\" : \"true\" } ) else : return self . _hs_session . retrieve_file ( urljoin ( self . _resource_path , \"data\" , \"contents\" , path ), save_path )","title":"file_download()"},{"location":"resource/#hsclient.hydroshare.Resource.file_rename","text":"Rename a file on HydroShare :param path: The path to the file :param new_path: the renamed path to the file Source code in hsclient/hydroshare.py def file_rename ( self , path : str , new_path : str ) -> None : \"\"\" Rename a file on HydroShare :param path: The path to the file :param new_path: the renamed path to the file \"\"\" rename_path = urljoin ( self . _hsapi_path , \"functions\" , \"move-or-rename\" ) self . _hs_session . post ( rename_path , status_code = 200 , data = { \"source_path\" : path , \"target_path\" : new_path }) self . refresh ()","title":"file_rename()"},{"location":"resource/#hsclient.hydroshare.Resource.file_unzip","text":"Unzips a file on HydroShare :param path: The path to the file to unzip Source code in hsclient/hydroshare.py def file_unzip ( self , path : str ) -> None : \"\"\" Unzips a file on HydroShare :param path: The path to the file to unzip \"\"\" if not path . endswith ( \".zip\" ): raise Exception ( \"File {} is not a zip, and cannot be unzipped\" . format ( path )) unzip_path = urljoin ( self . _hsapi_path , \"functions\" , \"unzip\" , \"data\" , \"contents\" , path ) self . _hs_session . post ( unzip_path , status_code = 200 , data = { \"overwrite\" : \"true\" , \"ingest_metadata\" : \"true\" }) self . refresh ()","title":"file_unzip()"},{"location":"resource/#hsclient.hydroshare.Resource.file_upload","text":"Uploads files to a folder in HydroShare :param *files: The local file paths to upload :param destination_path: The path on HydroShare to upload the files to, defaults to the root contents directory Source code in hsclient/hydroshare.py def file_upload ( self , * files : str , destination_path : str = \"\" ) -> None : \"\"\" Uploads files to a folder in HydroShare :param *files: The local file paths to upload :param destination_path: The path on HydroShare to upload the files to, defaults to the root contents directory \"\"\" if len ( files ) == 1 : self . _upload ( files [ 0 ], destination_path = destination_path ) else : with tempfile . TemporaryDirectory () as tmpdir : zipped_file = urljoin ( tmpdir , 'files.zip' ) with ZipFile ( urljoin ( tmpdir , zipped_file ), 'w' ) as zipped : for file in files : zipped . write ( file , basename ( file )) self . _upload ( zipped_file , destination_path = destination_path ) unzip_path = urljoin ( self . _hsapi_path , \"functions\" , \"unzip\" , \"data\" , \"contents\" , destination_path , 'files.zip' ) self . _hs_session . post ( unzip_path , status_code = 200 , data = { \"overwrite\" : \"true\" , \"ingest_metadata\" : \"true\" } ) self . refresh ()","title":"file_upload()"},{"location":"resource/#hsclient.hydroshare.Resource.file_zip","text":"Zip a file on HydroShare :param path: The path to the file :param zip_name: The name of the zipped file :param remove_file: Defaults to True, set to False to not delete the file that was zipped Source code in hsclient/hydroshare.py def file_zip ( self , path : str , zip_name : str = None , remove_file : bool = True ) -> None : \"\"\" Zip a file on HydroShare :param path: The path to the file :param zip_name: The name of the zipped file :param remove_file: Defaults to True, set to False to not delete the file that was zipped \"\"\" zip_name = basename ( path ) + \".zip\" if not zip_name else zip_name data = { \"input_coll_path\" : path , \"output_zip_file_name\" : zip_name , \"remove_original_after_zip\" : remove_file } zip_path = urljoin ( self . _hsapi_path , \"functions\" , \"zip\" ) self . _hs_session . post ( zip_path , status_code = 200 , data = data ) self . refresh ()","title":"file_zip()"},{"location":"resource/#hsclient.hydroshare.Resource.folder_create","text":"Creates a folder on HydroShare :param folder: the folder path to create Source code in hsclient/hydroshare.py def folder_create ( self , folder : str ) -> None : \"\"\" Creates a folder on HydroShare :param folder: the folder path to create \"\"\" path = urljoin ( self . _hsapi_path , \"folders\" , folder ) self . _hs_session . put ( path , status_code = 201 )","title":"folder_create()"},{"location":"resource/#hsclient.hydroshare.Resource.folder_delete","text":"Deletes a folder on HydroShare :param path: the path to the folder Source code in hsclient/hydroshare.py def folder_delete ( self , path : str = None ) -> None : \"\"\" Deletes a folder on HydroShare :param path: the path to the folder \"\"\" self . _delete_file_folder ( path ) self . refresh ()","title":"folder_delete()"},{"location":"resource/#hsclient.hydroshare.Resource.folder_download","text":"Downloads a folder from HydroShare :param path: The path to folder :param save_path: The local path to save the download to, defaults to the current directory :returns: The path to the download zipped folder Source code in hsclient/hydroshare.py def folder_download ( self , path : str , save_path : str = \"\" ): \"\"\" Downloads a folder from HydroShare :param path: The path to folder :param save_path: The local path to save the download to, defaults to the current directory :returns: The path to the download zipped folder \"\"\" return self . _hs_session . retrieve_zip ( urljoin ( self . _resource_path , \"data\" , \"contents\" , path ), save_path , params = { \"zipped\" : \"true\" } )","title":"folder_download()"},{"location":"resource/#hsclient.hydroshare.Resource.folder_rename","text":"Renames a folder on HydroShare :param path: the path to the folder to rename :param new_path: the new path folder name Source code in hsclient/hydroshare.py def folder_rename ( self , path : str , new_path : str ) -> None : \"\"\" Renames a folder on HydroShare :param path: the path to the folder to rename :param new_path: the new path folder name \"\"\" self . file_rename ( path = path , new_path = new_path )","title":"folder_rename()"},{"location":"resource/#hsclient.hydroshare.Resource.new_version","text":"Creates a new version of the resource on HydroShare :return: A Resource object of the newly created resource version Source code in hsclient/hydroshare.py def new_version ( self ): \"\"\" Creates a new version of the resource on HydroShare :return: A Resource object of the newly created resource version \"\"\" path = urljoin ( self . _hsapi_path , \"version\" ) response = self . _hs_session . post ( path , status_code = 202 ) resource_id = response . text return Resource ( \"/resource/ {} /data/resourcemap.xml\" . format ( resource_id ), self . _hs_session )","title":"new_version()"},{"location":"resource/#hsclient.hydroshare.Resource.reference_create","text":"Creates a HydroShare reference object to reference content outside of the resource :param file_name: the file name of the resulting .url file :param url: the url of the referenced content :param path: the path to create the reference in Source code in hsclient/hydroshare.py def reference_create ( self , file_name : str , url : str , path : str = '' ) -> None : \"\"\" Creates a HydroShare reference object to reference content outside of the resource :param file_name: the file name of the resulting .url file :param url: the url of the referenced content :param path: the path to create the reference in \"\"\" request_path = urljoin ( self . _hsapi_path . replace ( self . resource_id , \"\" ), \"data-store-add-reference\" ) self . _hs_session . post ( request_path , data = { \"res_id\" : self . resource_id , \"curr_path\" : path , \"ref_name\" : file_name , \"ref_url\" : url }, status_code = 200 , ) self . refresh ()","title":"reference_create()"},{"location":"resource/#hsclient.hydroshare.Resource.reference_update","text":"Updates a HydroShare reference object :param file_name: the file name for the .url file :param url: the url of the referenced content :param path: the path to the directory where the reference is located Source code in hsclient/hydroshare.py def reference_update ( self , file_name : str , url : str , path : str = '' ) -> None : \"\"\" Updates a HydroShare reference object :param file_name: the file name for the .url file :param url: the url of the referenced content :param path: the path to the directory where the reference is located \"\"\" request_path = urljoin ( self . _hsapi_path . replace ( self . resource_id , \"\" ), \"data_store_edit_reference_url\" ) self . _hs_session . post ( request_path , data = { \"res_id\" : self . resource_id , \"curr_path\" : path , \"url_filename\" : file_name , \"new_ref_url\" : url }, status_code = 200 , ) self . refresh ()","title":"reference_update()"},{"location":"resource/#hsclient.hydroshare.Resource.save","text":"Saves the metadata to HydroShare Source code in hsclient/hydroshare.py def save ( self ) -> None : \"\"\"Saves the metadata to HydroShare\"\"\" metadata_string = rdf_string ( self . _retrieved_metadata , rdf_format = \"xml\" ) path = urljoin ( self . _hsapi_path , \"ingest_metadata\" ) self . _hs_session . upload_file ( path , files = { 'file' : ( 'resourcemetadata.xml' , metadata_string )}) self . refresh ()","title":"save()"},{"location":"resource/#hsclient.hydroshare.Resource.set_sharing_status","text":"Set the sharing status of the resource to public or private :param public: bool, set to True for public, False for private Source code in hsclient/hydroshare.py def set_sharing_status ( self , public : bool ): \"\"\" Set the sharing status of the resource to public or private :param public: bool, set to True for public, False for private \"\"\" path = urljoin ( \"hsapi\" , \"resource\" , \"accessRules\" , self . resource_id ) data = { 'public' : public } self . _hs_session . put ( path , status_code = 200 , data = data )","title":"set_sharing_status()"},{"location":"resource/#hsclient.hydroshare.Resource.system_metadata","text":"The system metadata associated with the HydroShare resource returns: JSON object Source code in hsclient/hydroshare.py def system_metadata ( self ): \"\"\" The system metadata associated with the HydroShare resource returns: JSON object \"\"\" hsapi_path = urljoin ( self . _hsapi_path , 'sysmeta' ) return self . _hs_session . get ( hsapi_path , status_code = 200 ) . json ()","title":"system_metadata()"}]}